guid,text,extra,tags
"o,6.sB47D4","<p>There are two types of iteration: {{c1::bounded}} and {{c1::unbounded}}. {{c1::Bounded}} is for numerically controlled cycles (for, do), and {{c1::unbounded}} is for logically controlled cycles (while, repeat).</p>",.,"CS::PLChapter06, CS::programming-languages"
x=wso>6kGl,"<p>Commands are more in {{c1::imperative}} languages, while expressions are more in {{c1::functional}} languages</p>",.,"CS::PLChapter07, CS::programming-languages"
ptGU3Nt]km,"All common programming languages using static scope, also use {{c1::deep}} binding",.,"CS::PLChapter07, CS::programming-languages"
NdCEUm6#mJ,"An object is a box that contains: <br/>{{c1::Hidden Data}}: variables, values; even functions.<br/>{{c2::Public operations}}: methods",.,"CS::PLChapter09, CS::programming-languages"
Gr7bP9`A=],"It is possible to discern types of operation and an “execution method” common to all interpreters. The type of operation executed by the interpreter and assocated data structures, fall into the following categories: <br/> 1. {{c1::Operations for processing primitive data}} <br/> 2. {{c2::Operations and data structures for controlling the sequence of execution of operations}} <br/> 3. {{c3::Operations and data structures for controlling data transfers}} <br/> 4. {{c4::Operations and data structures for memory management}}.",.,"CS::PLChapter01, CS::programming-languages"
"k<,H>VgOw0","The storage component of a physical computer is composed of various levels of memory. Secondary memory implemented using {{c1::optical or magnetic components}}; primary memory, organised as a linear sequence of {{c2::cells, or words}}, of fixed size (usually a multiple of 8 bits); {{c3::cache}} and the {{c4::<i>registers</i>}} which are internal to the CPU",.,"CS::PLChapter01, CS::programming-languages"
H];wjpm-*P,"A context-free grammar is a quadruple (NT, T, R, S) where: <br/> 1. NT is {{c1::a finite set of symbols (non-terminal symbols, or variables, or syntactic categories).}} <br/> 2. T is {{c2::a finite set of symbols  (terminal symbols)}} <br/> 3. R is {{c3::a finite set of productions (or rules), each of which is composed of an expression of the form \(V \to \omega \) where \(V\) (the head of the production) is a single non-terminal symbol and \(\omega \) (the body) is a string composed of zero or more terminal or non-terminal symbols (that is \(\omega \) is a string over \(T \cup NT\)) }} <br/> 4. S is {{c4::an element of NT (the initial symbol) }}",.,"CS::PLChapter02, CS::programming-languages"
n[.!/9fXOF,"When a new block is entered, the following modifications are made to the environment: <br/> 1. {{c1::Associations between locally declared names and the corresponding denotable objects are created}} <br/> 2. {{c2::Associations with names declared external to and redefined inside the block are deactivated}}",.,"CS::PLChapter04, CS::programming-languages"
x`^jXQ^_aA,"When a block is exited, the environment is modified as follows: <br/> 1. {{c1::The associations for names declared locally to the block and the objects they denote are destroyed.}} <br/> 2. {{c2::The associations are reactivated between names that existed external to the block and which were redefined inside it.}}",.,"CS::PLChapter04, CS::programming-languages"
plKgR02b^K,"The fields for an activation record for procedures are: <br/> 1. {{c1::The same as for in-line block: intermediate results, local variables, dynamic chain pointer}} <br/> 2. {{c2::Static Chain Pointer}} This stores the information needed to implement the static scope rules <br/> 3. {{c3::Return address}} Ttthis contains the address of the first instruction to execute after the call to the current procedure/function has terminated execution. <br/> 4. {{c4::Returned result}} This is present only in functions. Contains tthe address of the memory location where the subprogram stores the value to be returned by the function when it terminates. This memory location is inside the caller’s activation record. <br/> 5. {{c5::Parameters}} These are the values of actual parameters used to call the procedure or function are stored here. <br/>",.,"CS::PLChapter05, CS::programming-languages"
HhX+N.H!%9,"When using fixed-length blocks in memory management, the heap is divided into a certain number of elements, or blocks, of fairly {{c1::small}} fixed length, linked intto a list structure called {{c2::the <i>free list</i>}}.",.,"CS::PLChapter05, CS::programming-languages"
Jx/fSg_(;%,Assignment is the basic command that allows the modification of the values associated with {{c1::modifiable variables}}. It also modifies {{c2::the state}} in imperative languages.,.,"CS::PLChapter06, CS::programming-languages"
md%D&z#P!|,"There are four types of commands: <br/> 1. {{c1::<b>Assignment</b>}} This is the basic command in imperative languages (and in “impure” declarative languages); it expresses the elementary computation step. <br/> 2. {{c2::<b>Commands for explicit sequence control</b>}} These are the sequential command and <i>goto</i>. Let us consider, in addition, the composite command, which allows us to consider a group fo commands as a single one, as being in this category. <br/> 3. {{c3::<b>Conditional (or selection) commands</b>}} These are the commands which allow the specification of alternative paths that the competition can take. They depend on the satisfaction of specific conditions. <br/> 4. {{c4::<b>Iterative commands</b>}} These allow the repetition of a given command for a predefined number of times, or until the satisfaction of specific conditions",.,"CS::PLChapter06, CS::programming-languages"
Do&d;kQbKy,The copy rule requires that the actual parameter must be evaluated {{c1::every time}} that the formal parameter is encountered during execution.,.,"CS::PLChapter07, CS::programming-languages"
F!wNbY+BaO,"The handling of an exception in general requires two different constructs: <br/> A mechanism that defines a capsule around a portion of code (the {{c1::<i>protected block</i>}}), with the aim of intercepting the exceptions that are to be handled inside the capsule itself. <br/> The definition of a handler for the exception, statically linked to the protected block. Control is transferred to {{c2::the handler}} then the capsule intercepts the exception.",.,"CS::PLChapter07, CS::programming-languages"
E^#[O=g)gd,"Data types are present in programming languages for at least three different reasons: <br/> 1. At the {{c1::design level}}, as support for the conceptual organisation. <br/> 2. At the {{c2::programlevel}}, as support for correctness <br/> 3. At the {{c3::translation level}}, as support for the implementation.",.,"CS::PLChapter08, CS::programming-languages"
$5bNk~/f$,A type system consists of the following: <br/> 1. The set of {{c1::predefined types}} of the language. <br/> 2. The mechanisms which permit {{c2::the definition of new types.}} <br/> 3. The mechanisms for the {{c3::control of types}} among which we distinguish the following: <ul><li>{{c4::Equivalence rules}} which specify when two formally different types correspond to the same type</li><li>{{c5::Compatibility rules}} specifying when a value of a one type can be used in a context in which a different type would be required</li><li>{{c6::Rules and techniques}} for type inference which specify how the language assigns a type to a complex expresion based on information about its components.</ul> <br/> 4. The specification as to whether (or which) constraints are {{c7::statically or dynamically}} checked.,.,"CS::PLChapter08, CS::programming-languages"
Lb~cjra|$[,"The most important and common composite types are: <br> {{c1::Record (or structure}}, a collection of values in general of different types. <br/> {{c2::Array (or vector)}}, a collection of values of the same type. <br/> {{c3::Set}}, subsets of a base type, generally ordinal types <br/> {{c4::Pointer}} l-values, which permit access to data of another type. <br/> {{c5::Recursive types}} types defined by recursion, using constants and constructors; particular cases of {{c5::recursive types}} are lists, tress etc. ",.,"CS::PLChapter08, CS::programming-languages"
fb`De<G6m(,"Structural equivalence of types is the (least) equivalence realtion satisfying the following properties: <br/> <ul> 
<li>The name of a type is equivalent to {{c1::itself}}</li>
<li> If a type T is introduced with the definition <i>type T = expression</i>, <i>T</i> is {{c2::equivalent}} to {{c3::<i>expression</i>}}</li>
<li>If two types are constructed by applying the same type constructor to equivalent types, then the two types are {{c4::equivalent}}</li>
</ul>",.,"CS::PLChapter08, CS::programming-languages"
IRe6oD(7w*,"When a language allows multiple inheritance, and both superclasses have methods of the same name, there are three different ways in which we can find out which we want to use (none of which is totally satisfactory): <br/> 1. {{c1::Forbid name clashes syntactically}} <br/> 2. Require that any conflict should be resolved by the programmer’s approriately qualifying every refernce to a name that is in conflict. For example, the body of h in class C, should be written as {{c2::B::f() or as A::f()}}, which is the solution adopted by C++ <br/> 3. Decide upon a convention for solving the conflict, for example favouring the first-class named in the {{c3::extending}} clause.",.,"CS::PLChapter10, CS::programming-languages"
